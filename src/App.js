import React, { useState, useEffect } from 'react';\nimport QuestionCard from './components/QuestionCard';\nimport ProgressBar from './components/ProgressBar';\nimport ResultsScreen from './components/ResultsScreen';\nimport DimensionSelector from './components/DimensionSelector';\nimport { questions, dimensionGroups } from './data/questions';\nimport { expandedQuestions, expandedDimensionGroups } from './data/expandedQuestions';\n\nfunction App() {\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [answers, setAnswers] = useState({});\n  const [showResults, setShowResults] = useState(false);\n  const [results, setResults] = useState(null);\n  const [showDimensionSelector, setShowDimensionSelector] = useState(true);\n  const [selectedDimension, setSelectedDimension] = useState(null);\n  const [filteredQuestions, setFilteredQuestions] = useState([]);\n  const [isExitModalOpen, setIsExitModalOpen] = useState(false);\n  const [isExpandedMode, setIsExpandedMode] = useState(false);\n  const [activeQuestionSet, setActiveQuestionSet] = useState([]);\n  const [activeDimensionGroups, setActiveDimensionGroups] = useState({});\n\n  // Load saved progress from localStorage if available\n  useEffect(() => {\n    const savedProgress = localStorage.getItem('bumnTestProgress');\n    if (savedProgress) {\n      const { \n        answers: savedAnswers, \n        currentIndex: savedIndex,\n        selectedDimension: savedDimension,\n        isExpandedMode: savedExpandedMode = false\n      } = JSON.parse(savedProgress);\n      \n      setAnswers(savedAnswers);\n      setCurrentIndex(savedIndex);\n      setIsExpandedMode(savedExpandedMode);\n      \n      if (savedDimension) {\n        setSelectedDimension(savedDimension);\n        filterQuestionsByDimension(savedDimension, savedExpandedMode);\n        setShowDimensionSelector(false);\n      } else if (savedExpandedMode) {\n        // If expanded mode was active but no dimension was selected\n        const combinedQuestions = [...questions, ...expandedQuestions];\n        setActiveQuestionSet(combinedQuestions);\n        setActiveDimensionGroups({...dimensionGroups, ...expandedDimensionGroups});\n        setShowDimensionSelector(false);\n      }\n    }\n  }, []);\n\n  // Filter questions based on selected dimension and mode\n  const filterQuestionsByDimension = (dimensionId, expanded = false) => {\n    if (!dimensionId) {\n      if (expanded) {\n        // For expanded mode without specific dimension\n        const combinedQuestions = [...questions, ...expandedQuestions];\n        setActiveQuestionSet(combinedQuestions);\n        setFilteredQuestions(combinedQuestions);\n        setActiveDimensionGroups({...dimensionGroups, ...expandedDimensionGroups});\n      } else {\n        // Standard full test\n        setActiveQuestionSet(questions);\n        setFilteredQuestions(questions);\n        setActiveDimensionGroups(dimensionGroups);\n      }\n      return;\n    }\n    \n    // For specific dimension tests\n    const standardQuestionIds = dimensionGroups[dimensionId] || [];\n    const expandedQuestionIds = expanded ? (expandedDimensionGroups[dimensionId] || []) : [];\n    const allQuestionIds = [...standardQuestionIds, ...expandedQuestionIds];\n    \n    const allQuestions = expanded ? [...questions, ...expandedQuestions] : questions;\n    const filtered = allQuestions.filter(question => allQuestionIds.includes(question.id));\n    \n    setActiveQuestionSet(allQuestions);\n    setFilteredQuestions(filtered);\n    \n    // Set active dimension groups based on mode\n    if (expanded) {\n      const combinedGroups = {};\n      for (const dimension in dimensionGroups) {\n        combinedGroups[dimension] = [\n          ...(dimensionGroups[dimension] || []),\n          ...(expandedDimensionGroups[dimension] || [])\n        ];\n      }\n      setActiveDimensionGroups(combinedGroups);\n    } else {\n      setActiveDimensionGroups(dimensionGroups);\n    }\n  };\n\n  // Save progress to localStorage whenever answers, currentIndex, or selectedDimension changes\n  useEffect(() => {\n    if (Object.keys(answers).length > 0) {\n      localStorage.setItem('bumnTestProgress', JSON.stringify({ \n        answers, \n        currentIndex,\n        selectedDimension,\n        isExpandedMode \n      }));\n    }\n  }, [answers, currentIndex, selectedDimension, isExpandedMode]);\n\n  const handleAnswer = (questionId, optionIndex) => {\n    setAnswers(prev => ({ ...prev, [questionId]: optionIndex }));\n    \n    // Move to next question if not at the end\n    if (currentIndex < filteredQuestions.length - 1) {\n      setCurrentIndex(prev => prev + 1);\n    }\n  };\n\n  const handlePrevious = () => {\n    if (currentIndex > 0) {\n      setCurrentIndex(prev => prev - 1);\n    }\n  };\n\n  const handleDimensionSelect = (dimensionId) => {\n    setSelectedDimension(dimensionId);\n    filterQuestionsByDimension(dimensionId, isExpandedMode);\n    setCurrentIndex(0);\n    setAnswers({});\n    setShowDimensionSelector(false);\n  };\n\n  const handleStartFullTest = () => {\n    setSelectedDimension(null);\n    setIsExpandedMode(false);\n    filterQuestionsByDimension(null, false);\n    setCurrentIndex(0);\n    setAnswers({});\n    setShowDimensionSelector(false);\n  };\n\n  const handleStartExpandedTest = () => {\n    setSelectedDimension(null);\n    setIsExpandedMode(true);\n    filterQuestionsByDimension(null, true);\n    setCurrentIndex(0);\n    setAnswers({});\n    setShowDimensionSelector(false);\n  };\n\n  const handleSubmit = () => {\n    // Calculate results\n    const results = calculateResults(answers);\n    setResults(results);\n    setShowResults(true);\n    \n    // Clear local storage after submission\n    localStorage.removeItem('bumnTestProgress');\n  };\n\n  const calculateResults = (answers) => {\n    // Pemetaan dari dimensionTrait ke dimensi\n    const traitToDimension = {\n      'structure': 'structureVsFlexibility',\n      'flexibility': 'structureVsFlexibility',\n      'introvert': 'introvertVsExtrovert',\n      'extrovert': 'introvertVsExtrovert',\n      'practical': 'practicalVsConceptual',\n      'conceptual': 'practicalVsConceptual',\n      'risk': 'riskVsCaution',\n      'caution': 'riskVsCaution',\n      'independent': 'independentVsCollaborative',\n      'collaborative': 'independentVsCollaborative'\n    };\n\n    // Konfigurasi trait yang menjadi skor positif dalam setiap dimensi\n    const positiveTrait = {\n      'structureVsFlexibility': 'structure',\n      'introvertVsExtrovert': 'introvert',\n      'practicalVsConceptual': 'practical',\n      'riskVsCaution': 'caution',\n      'independentVsCollaborative': 'independent'\n    };\n\n    // Initialize scores for each dimension\n    const dimensionScores = {};\n    const dimensionConsistency = {};\n    const traitCounts = {};\n    \n    // Initialize all dimensions or just the selected one\n    if (selectedDimension) {\n      dimensionScores[selectedDimension] = 0;\n      dimensionConsistency[selectedDimension] = 0;\n      \n      // Initialize trait counts for the selected dimension\n      const positiveTraitKey = positiveTrait[selectedDimension];\n      const negativeTraitKey = selectedDimension === 'structureVsFlexibility' ? 'flexibility' : \n                               selectedDimension === 'introvertVsExtrovert' ? 'extrovert' :\n                               selectedDimension === 'practicalVsConceptual' ? 'conceptual' :\n                               selectedDimension === 'riskVsCaution' ? 'risk' : 'collaborative';\n      \n      traitCounts[positiveTraitKey] = 0;\n      traitCounts[negativeTraitKey] = 0;\n    } else {\n      Object.keys(activeDimensionGroups).forEach(dimension => {\n        dimensionScores[dimension] = 0;\n        dimensionConsistency[dimension] = 0;\n      });\n      \n      // Initialize all trait counts\n      Object.values(positiveTrait).forEach(trait => {\n        traitCounts[trait] = 0;\n      });\n      traitCounts['flexibility'] = 0;\n      traitCounts['extrovert'] = 0;\n      traitCounts['conceptual'] = 0;\n      traitCounts['risk'] = 0;\n      traitCounts['collaborative'] = 0;\n    }\n    \n    // Calculate raw scores for each dimension based on metadata\n    Object.entries(answers).forEach(([questionId, answerIndex]) => {\n      const qId = parseInt(questionId);\n      const question = activeQuestionSet.find(q => q.id === qId);\n      \n      if (question && question.metadata && question.metadata[answerIndex]) {\n        const selectedTrait = question.metadata[answerIndex].dimensionTrait;\n        const dimension = traitToDimension[selectedTrait];\n        \n        // If we're only calculating for a specific dimension, skip others\n        if (selectedDimension && dimension !== selectedDimension) return;\n        \n        // Count the trait chosen\n        traitCounts[selectedTrait] = (traitCounts[selectedTrait] || 0) + 1;\n        \n        // Add to dimension score if the positive trait was chosen\n        const positiveTraitForDimension = positiveTrait[dimension];\n        if (selectedTrait === positiveTraitForDimension) {\n          dimensionScores[dimension] += 1;\n        }\n      }\n    });\n    \n    // Calculate consistency within each dimension\n    Object.entries(activeDimensionGroups).forEach(([dimension, questionIds]) => {\n      // If we're only calculating for a specific dimension, skip others\n      if (selectedDimension && dimension !== selectedDimension) return;\n      \n      // Skip if dimension has less than 2 questions\n      if (questionIds.length < 2) return;\n      \n      // Get positive and negative trait names for this dimension\n      const positiveTrait = {\n        'structureVsFlexibility': 'structure',\n        'introvertVsExtrovert': 'introvert',\n        'practicalVsConceptual': 'practical',\n        'riskVsCaution': 'caution',\n        'independentVsCollaborative': 'independent'\n      }[dimension];\n      \n      const negativeTrait = {\n        'structureVsFlexibility': 'flexibility',\n        'introvertVsExtrovert': 'extrovert',\n        'practicalVsConceptual': 'conceptual',\n        'riskVsCaution': 'risk',\n        'independentVsCollaborative': 'collaborative'\n      }[dimension];\n      \n      // Count answers for each option using the traits\n      const positiveTraitCount = traitCounts[positiveTrait] || 0;\n      const negativeTraitCount = traitCounts[negativeTrait] || 0;\n      \n      // Calculate consistency as a percentage\n      const totalAnswered = positiveTraitCount + negativeTraitCount;\n      if (totalAnswered === 0) return;\n      \n      const dominantOption = Math.max(positiveTraitCount, negativeTraitCount);\n      const consistencyPercentage = (dominantOption / totalAnswered) * 100;\n      dimensionConsistency[dimension] = consistencyPercentage;\n    });\n    \n    // Calculate total consistency and final score\n    let totalConsistency = 0;\n    let dimensionCount = 0;\n    \n    Object.values(dimensionConsistency).forEach(consistency => {\n      if (consistency > 0) {\n        totalConsistency += consistency;\n        dimensionCount++;\n      }\n    });\n    \n    const averageConsistency = dimensionCount > 0 ? totalConsistency / dimensionCount : 0;\n    \n    // Calculate total raw score\n    const rawScore = Object.values(dimensionScores).reduce((sum, score) => sum + score, 0);\n    \n    // Adjust score based on consistency\n    // If 100% consistent, score is unchanged\n    // If 50% consistent (random), score is halved\n    const consistencyMultiplier = averageConsistency / 100;\n    \n    // For full test or expanded test, maxPossibleScore is all questions in filtered set\n    // For single dimension, maxPossibleScore is just the questions for that dimension\n    const maxPossibleScore = filteredQuestions.length;\n    \n    const finalScore = Math.round(rawScore * consistencyMultiplier);\n    const scorePercentage = Math.round((finalScore / maxPossibleScore) * 100);\n    \n    return {\n      dimensionScores,\n      dimensionConsistency,\n      rawScore,\n      averageConsistency,\n      finalScore,\n      maxPossibleScore,\n      scorePercentage,\n      dimensionGroups: activeDimensionGroups,\n      traitCounts,\n      selectedDimension, // Include info about whether this was a single dimension test\n      isExpandedMode\n    };\n  };\n\n  // Check if all questions have been answered\n  const allQuestionsAnswered = filteredQuestions.every(q => answers[q.id] !== undefined);\n  const answeredCount = filteredQuestions.filter(q => answers[q.id] !== undefined).length;\n\n  // Show results if the test is complete\n  if (showResults) {\n    return <ResultsScreen results={results} />;\n  }\n\n  // Show dimension selector if we're at that stage\n  if (showDimensionSelector) {\n    return (\n      <DimensionSelector \n        onSelectDimension={handleDimensionSelect}\n        onStartFullTest={handleStartFullTest}\n        onStartExpandedTest={handleStartExpandedTest}\n      />\n    );\n  }\n\n  // Exit confirmation modal\n  const ExitConfirmationModal = () => (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\">\n      <div className=\"bg-white rounded-lg shadow-xl max-w-md w-full p-6 transform transition-all\">\n        <h3 className=\"text-lg font-bold text-gray-900 mb-3\">Kembali ke Pemilihan Dimensi?</h3>\n        <p className=\"text-gray-600 mb-6\">\n          Jawaban Anda akan tersimpan dan Anda dapat melanjutkan tes ini nanti. Yakin ingin kembali ke menu pemilihan dimensi?\n        </p>\n        <div className=\"flex justify-end space-x-3\">\n          <button\n            onClick={() => setIsExitModalOpen(false)}\n            className=\"px-4 py-2 rounded bg-gray-200 text-gray-800 font-medium hover:bg-gray-300 transition-colors\"\n          >\n            Batal\n          </button>\n          <button\n            onClick={() => {\n              setIsExitModalOpen(false);\n              setShowDimensionSelector(true);\n            }}\n            className=\"px-4 py-2 rounded bg-blue-600 text-white font-medium hover:bg-blue-700 transition-colors\"\n          >\n            Ya, Kembali\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n\n  return (\n    <div className=\"min-h-screen bg-gray-100 py-8 px-4 sm:px-6 lg:px-8\">\n      <div className=\"max-w-2xl mx-auto\">\n        <header className=\"text-center mb-8\">\n          <h1 className=\"text-3xl font-bold text-gray-900\">\n            {selectedDimension ? \n              `Tes ${dimensionGroupToTitle(selectedDimension)}${isExpandedMode ? ' (Expanded)' : ''}` : \n              isExpandedMode ? 'Tes Expanded Learning Agility BUMN' : 'Tes Learning Agility BUMN'}\n          </h1>\n          <p className=\"mt-2 text-lg text-gray-600\">\n            Pilih pernyataan yang paling sesuai dengan pengalaman pribadi Anda\n          </p>\n          {isExpandedMode && (\n            <div className=\"mt-2 inline-block px-3 py-1 bg-red-100 text-red-800 rounded-full text-sm\">\n              Mode Expanded Question - Versi Latihan Diperluas\n            </div>\n          )}\n        </header>\n\n        <ProgressBar \n          current={currentIndex + 1} \n          total={filteredQuestions.length} \n          answeredCount={answeredCount}\n        />\n\n        <QuestionCard\n          question={filteredQuestions[currentIndex]}\n          selectedOption={answers[filteredQuestions[currentIndex].id]}\n          onAnswer={handleAnswer}\n        />\n\n        <div className=\"flex justify-between mt-6\">\n          <button\n            onClick={handlePrevious}\n            disabled={currentIndex === 0}\n            className={`px-6 py-2.5 rounded-md font-medium flex items-center transition-colors ${\n              currentIndex === 0 \n                ? 'bg-gray-100 text-gray-400 cursor-not-allowed' \n                : 'bg-white text-gray-700 hover:bg-gray-100 border border-gray-300 shadow-sm'\n            }`}\n          >\n            <svg className=\"w-5 h-5 mr-1\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 19l-7-7 7-7\" />\n            </svg>\n            Sebelumnya\n          </button>\n          \n          {currentIndex === filteredQuestions.length - 1 ? (\n            <button\n              onClick={handleSubmit}\n              disabled={!allQuestionsAnswered}\n              className={`px-6 py-2.5 rounded-md font-medium flex items-center transition-colors ${\n                !allQuestionsAnswered \n                  ? 'bg-blue-300 text-white cursor-not-allowed' \n                  : 'bg-blue-600 text-white hover:bg-blue-700 shadow-sm'\n              }`}\n            >\n              Selesai\n              <svg className=\"w-5 h-5 ml-1\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n              </svg>\n            </button>\n          ) : (\n            <button\n              onClick={() => setCurrentIndex(prev => prev + 1)}\n              className=\"px-6 py-2.5 rounded-md bg-blue-600 text-white font-medium hover:bg-blue-700 transition-colors shadow-sm flex items-center\"\n            >\n              Selanjutnya\n              <svg className=\"w-5 h-5 ml-1\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 5l7 7-7 7\" />\n              </svg>\n            </button>\n          )}\n        </div>\n\n        <div className=\"mt-8 text-center\">\n          <button\n            onClick={() => setIsExitModalOpen(true)}\n            className=\"text-blue-600 hover:text-blue-800 text-sm font-medium flex items-center justify-center mx-auto\"\n          >\n            <svg className=\"w-4 h-4 mr-1\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M11 17l-5-5m0 0l5-5m-5 5h12\" />\n            </svg>\n            Kembali ke Pemilihan Dimensi\n          </button>\n        </div>\n      </div>\n\n      {isExitModalOpen && <ExitConfirmationModal />}\n    </div>\n  );\n}\n\n// Helper function to convert dimension ID to readable title\nfunction dimensionGroupToTitle(dimensionId) {\n  const titles = {\n    'structureVsFlexibility': 'Struktur vs Fleksibilitas',\n    'introvertVsExtrovert': 'Introvert vs Ekstrovert',\n    'practicalVsConceptual': 'Praktis vs Konseptual',\n    'riskVsCaution': 'Pengambil Risiko vs Kehati-hatian',\n    'independentVsCollaborative': 'Mandiri vs Kolaboratif'\n  };\n  \n  return titles[dimensionId] || dimensionId;\n}\n\nexport default App;